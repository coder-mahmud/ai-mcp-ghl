import { AxiosInstance, AxiosRequestConfig, AxiosResponse, InternalAxiosRequestConfig } from 'axios';
import { Associations } from './code/associations/associations';
import { Blogs } from './code/blogs/blogs';
import { Businesses } from './code/businesses/businesses';
import { Calendars } from './code/calendars/calendars';
import { Campaigns } from './code/campaigns/campaigns';
import { Companies } from './code/companies/companies';
import { Contacts } from './code/contacts/contacts';
import { Conversations } from './code/conversations/conversations';
import { Courses } from './code/courses/courses';
import { CustomFields } from './code/custom-fields/custom-fields';
import { CustomMenus } from './code/custom-menus/custom-menus';
import { EmailIsv } from './code/email-isv/email-isv';
import { Emails } from './code/emails/emails';
import { Forms } from './code/forms/forms';
import { Funnels } from './code/funnels/funnels';
import { Invoices } from './code/invoices/invoices';
import { Links } from './code/links/links';
import { Locations } from './code/locations/locations';
import { Marketplace } from './code/marketplace/marketplace';
import { Medias } from './code/medias/medias';
import { Oauth } from './code/oauth/oauth';
import { Objects } from './code/objects/objects';
import { Opportunities } from './code/opportunities/opportunities';
import { Payments } from './code/payments/payments';
import { PhoneSystem } from './code/phone-system/phone-system';
import { Products } from './code/products/products';
import { Proposals } from './code/proposals/proposals';
import { SaasApi } from './code/saas-api/saas-api';
import { Snapshots } from './code/snapshots/snapshots';
import { SocialMediaPosting } from './code/social-media-posting/social-media-posting';
import { Store } from './code/store/store';
import { Surveys } from './code/surveys/surveys';
import { Users } from './code/users/users';
import { VoiceAi } from './code/voice-ai/voice-ai';
import { Workflows } from './code/workflows/workflows';
import { SessionStorage } from './storage';
import { LogLevelType } from './logging';
import { WebhookManager } from './webhook';
declare module 'axios' {
    interface AxiosRequestConfig {
        __isRetryRequest?: boolean;
        __secutiryRequirements?: string[];
        __preferredTokenType?: 'company' | 'location';
    }
}
export interface HighLevelConfig {
    apiVersion?: string;
    privateIntegrationToken?: string;
    agencyAccessToken?: string;
    locationAccessToken?: string;
    clientId?: string;
    clientSecret?: string;
    sessionStorage?: SessionStorage;
    logLevel?: LogLevelType;
}
export type ValidConfig = {
    privateIntegrationToken: string;
    clientId?: string;
    clientSecret?: string;
    agencyAccessToken?: string;
    locationAccessToken?: string;
    apiVersion?: string;
    sessionStorage?: SessionStorage;
    logLevel?: LogLevelType;
} | {
    clientId: string;
    clientSecret: string;
    privateIntegrationToken?: undefined;
    agencyAccessToken?: string;
    locationAccessToken?: string;
    apiVersion?: string;
    sessionStorage?: SessionStorage;
    logLevel?: LogLevelType;
};
export declare class GHLError extends Error {
    statusCode?: number;
    response?: any;
    request?: any;
    constructor(message: string, statusCode?: number, response?: any, request?: any);
}
export interface RequestInterceptor {
    onFulfilled?: (config: InternalAxiosRequestConfig) => InternalAxiosRequestConfig | Promise<InternalAxiosRequestConfig>;
    onRejected?: (error: any) => any;
}
export interface ResponseInterceptor {
    onFulfilled?: (response: AxiosResponse) => AxiosResponse | Promise<AxiosResponse>;
    onRejected?: (error: any) => any;
}
/** HighLevel SDK Client */
export declare class HighLevel {
    private static readonly BASE_URL;
    private config;
    private httpClient;
    private sessionStorage;
    private logger;
    associations: Associations;
    blogs: Blogs;
    businesses: Businesses;
    calendars: Calendars;
    campaigns: Campaigns;
    companies: Companies;
    contacts: Contacts;
    conversations: Conversations;
    courses: Courses;
    customFields: CustomFields;
    customMenus: CustomMenus;
    emailIsv: EmailIsv;
    emails: Emails;
    forms: Forms;
    funnels: Funnels;
    invoices: Invoices;
    links: Links;
    locations: Locations;
    marketplace: Marketplace;
    medias: Medias;
    oauth: Oauth;
    objects: Objects;
    opportunities: Opportunities;
    payments: Payments;
    phoneSystem: PhoneSystem;
    products: Products;
    proposals: Proposals;
    saasApi: SaasApi;
    snapshots: Snapshots;
    socialMediaPosting: SocialMediaPosting;
    store: Store;
    surveys: Surveys;
    users: Users;
    voiceAi: VoiceAi;
    workflows: Workflows;
    webhooks: WebhookManager;
    constructor(config: ValidConfig);
    /**
     * Generate default headers for HTTP requests
     */
    private getDefaultHeaders;
    /**
     * Get appropriate token for API requests (internal method)
     * @param resourceId - Optional resourceId (companyId or locationId) for storage-based token lookup
     * @returns Authorization header value or null
     */
    getAuthToken(resourceId?: string): Promise<string | null>;
    /**
     * Helper method to try getting token from storage
     * @param resourceId - Resource ID for token lookup
     * @returns Bearer token if found, null otherwise
     */
    private fetchToken;
    /**
     * Check if a token should be refreshed based on expiration
     * @param sessionData - Session data containing expiration info
     * @returns True if token should be refreshed
     */
    private shouldRefreshToken;
    /**
     * Refresh token if expired and store the new token
     * @param resourceId - Resource ID for the session
     * @param sessionData - Current session data
     * @returns New Bearer token if successful, null otherwise
     */
    private refreshTokenIfNeeded;
    /**
     * Handle location token refresh fallback using company token
     * @param locationId - The location ID that failed to refresh
     * @param locationSessionData - The location session data
     * @returns New Bearer token if successful, null otherwise
     */
    private handleLocationTokenFallback;
    /**
     * Internal method to get token based on security requirements and request data
     * @param securityRequirements - Security requirements from OpenAPI spec
     * @param headers - Request headers
     * @param query - Query parameters
     * @param body - Request body
     * @param preferredTokenType - Preferred token type when both are available ('company' or 'location')
     * @returns Authorization header value or throws error
     */
    getTokenForSecurity(securityRequirements: string[], headers?: any, query?: any, body?: any, preferredTokenType?: 'company' | 'location'): Promise<string>;
    /**
     * Extract resourceId from request data based on security requirements
     * @param securityRequirements - Security requirements to determine token type
     * @param headers - Request headers
     * @param query - Query parameters
     * @param body - Request body
     * @param preferredTokenType - Preferred token type when both are available ('company' or 'location')
     * @returns Extracted resourceId (companyId or locationId)
     */
    extractResourceId(securityRequirements: string[], headers?: any, query?: any, body?: any, preferredTokenType?: 'company' | 'location'): string | null;
    /**
     * Setup default request and response interceptors
     */
    private setupDefaultInterceptors;
    /**
     * Handle response errors with proper error formatting
     */
    private handleResponseError;
    /**
     * Extract meaningful error message from API response
     */
    private extractErrorMessage;
    /**
     * Initialize all service instances with the shared HTTP client
     */
    private initializeServices;
    /**
     * Update session storage logger to match the main logger level
     */
    private updateSessionStorageLogger;
    /**
     * Initialize session storage (always exists now - either provided or auto-created)
     */
    private initializeSessionStorage;
    /**
     * Get the session storage instance (always available)
     */
    getSessionStorage(): SessionStorage;
    /**
     * Set or update the session storage instance
     */
    setSessionStorage(sessionStorage: SessionStorage): void;
    /**
     * Disconnect session storage
     */
    disconnectSessionStorage(): Promise<void>;
    /**
     * Update configuration and refresh all services
     */
    updateConfig(newConfig: Partial<HighLevelConfig & {
        agencyRefreshToken?: string | undefined;
        locationRefreshToken?: string | undefined;
    }>): void;
    /**
     * Set or update the private integration token (used without Bearer prefix)
     */
    setPrivateIntegrationToken(token: string): void;
    /**
     * Get current private integration token
     */
    getPrivateIntegrationToken(): string | undefined;
    /**
     * Get current temporary agency access token (read-only, set during initialization)
     */
    getAgencyAccessToken(): string | undefined;
    /**
     * Get current temporary location access token (read-only, set during initialization)
     */
    getLocationAccessToken(): string | undefined;
    /**
     * Set client ID for OAuth operations and update session storage
     */
    setClientId(clientId: string): void;
    /**
     * Get current client ID
     */
    getClientId(): string | undefined;
    /**
     * Set client secret for OAuth operations
     */
    setClientSecret(clientSecret: string): void;
    /**
     * Get current client secret
     */
    getClientSecret(): string | undefined;
    /**
     * Set API version
     */
    setApiVersion(version: string): void;
    /**
     * Get current configuration
     */
    getConfig(): HighLevelConfig;
    /**
     * Get current default headers
     */
    getHeaders(): Record<string, string>;
    /**
     * Add custom request interceptor
     */
    addRequestInterceptor(interceptor: RequestInterceptor): number;
    /**
     * Add custom response interceptor
     */
    addResponseInterceptor(interceptor: ResponseInterceptor): number;
    /**
     * Remove request interceptor by ID
     */
    removeRequestInterceptor(interceptorId: number): void;
    /**
     * Remove response interceptor by ID
     */
    removeResponseInterceptor(interceptorId: number): void;
    /**
     * Get the underlying HTTP client (for advanced usage)
     */
    getHttpClient(): AxiosInstance;
    /**
     * Make a raw HTTP request using the configured client
     */
    request<T = any>(config: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    /**
     * Health check method to test connectivity
     */
    healthCheck(): Promise<boolean>;
}
export default HighLevel;
//# sourceMappingURL=HighLevel.d.ts.map