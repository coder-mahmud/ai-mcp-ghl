"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemorySessionStorage = void 0;
const session_storage_1 = require("./session-storage");
const logging_1 = require("../logging");
/**
 * In-memory implementation of SessionStorage
 * Provides fast, non-persistent storage for sessions, tokens, and related data
 * Data is lost when the application restarts
 */
class MemorySessionStorage extends session_storage_1.SessionStorage {
    constructor(logger) {
        super(logger ? logger.child('Memory') : new logging_1.Logger('warn', 'GHL SDK Memory'));
        this.sessions = new Map();
        this.clientId = '';
        this.isInitialized = false;
    }
    /**
     * Set the client ID (called automatically by HighLevel class)
     * @param clientId - The client ID from HighLevel configuration
     */
    setClientId(clientId) {
        if (!clientId) {
            throw new Error('ClientId is required for session storage');
        }
        this.clientId = clientId;
        this.logger.debug(`MemorySessionStorage clientId set: ${this.getApplicationId()}`);
    }
    /**
     * Extract applicationId from clientId (first part before "-")
     * @returns Application ID extracted from clientId
     */
    getApplicationId() {
        if (!this.clientId) {
            throw new Error('ClientId not set. Make sure HighLevel class has a valid clientId configured.');
        }
        return this.clientId.split('-')[0];
    }
    /**
     * Generate a unique key combining applicationId and resourceId
     * @param resourceId - The resource identifier (companyId or locationId)
     * @returns Unique composite key
     */
    generateUniqueKey(resourceId) {
        const applicationId = this.getApplicationId();
        return `${applicationId}:${resourceId}`;
    }
    /**
     * Initialize the memory storage (no-op for memory storage)
     */
    async init() {
        this.isInitialized = true;
        this.logger.info('MemorySessionStorage initialized');
    }
    /**
     * Close the memory storage (clears all data)
     */
    async disconnect() {
        this.sessions.clear();
        this.isInitialized = false;
        this.logger.info('MemorySessionStorage disconnected and cleared');
    }
    /**
     * Create a collection (no-op for memory storage)
     * @param collectionName - Name of the collection (ignored in memory storage)
     */
    async createCollection(collectionName) {
        this.logger.debug(`MemorySessionStorage collection concept acknowledged: ${collectionName}`);
    }
    /**
     * Get a collection reference (returns collection name for memory storage)
     * @param collectionName - Name of the collection
     */
    async getCollection(collectionName) {
        return collectionName;
    }
    /**
     * Store a session in memory
     * @param resourceId - Unique identifier: it can be a companyId or a locationId
     * @param sessionData - Session data to store
     */
    async setSession(resourceId, sessionData) {
        try {
            const uniqueKey = this.generateUniqueKey(resourceId);
            const sessionDocument = {
                ...sessionData,
                expire_at: this.calculateExpireAt(sessionData.expires_in),
                createdAt: new Date(),
                updatedAt: new Date()
            };
            this.sessions.set(uniqueKey, sessionDocument);
            this.logger.debug(`Session stored in memory: ${uniqueKey}`);
        }
        catch (error) {
            this.logger.error(`Error storing session ${this.getApplicationId()}:${resourceId}:`, error);
            throw error;
        }
    }
    /**
     * Retrieve a session from memory
     * @param resourceId - Unique identifier: it can be a companyId or a locationId
     * @returns Session data or null if not found
     */
    async getSession(resourceId) {
        try {
            const uniqueKey = this.generateUniqueKey(resourceId);
            const sessionDocument = this.sessions.get(uniqueKey);
            if (!sessionDocument) {
                return null;
            }
            this.logger.debug(`Session retrieved from memory: ${uniqueKey}`);
            // Return the session data without the timestamps
            const { createdAt, updatedAt, ...sessionData } = sessionDocument;
            return sessionData;
        }
        catch (error) {
            this.logger.error(`Error retrieving session ${this.getApplicationId()}:${resourceId}:`, error);
            throw error;
        }
    }
    /**
     * Delete a session from memory
     * @param resourceId - Unique identifier: it can be a companyId or a locationId
     */
    async deleteSession(resourceId) {
        try {
            const uniqueKey = this.generateUniqueKey(resourceId);
            const deleted = this.sessions.delete(uniqueKey);
            if (deleted) {
                this.logger.debug(`Session deleted from memory: ${uniqueKey}`);
            }
            else {
                this.logger.debug(`Session not found for deletion: ${uniqueKey}`);
            }
        }
        catch (error) {
            this.logger.error(`Error deleting session ${this.getApplicationId()}:${resourceId}:`, error);
            throw error;
        }
    }
    /**
     * Get only the access token for a resource
     * @param resourceId - Unique identifier for the resource (companyId or locationId)
     * @returns Access token or null if not found
     */
    async getAccessToken(resourceId) {
        try {
            const uniqueKey = this.generateUniqueKey(resourceId);
            const sessionDocument = this.sessions.get(uniqueKey);
            return sessionDocument?.access_token || null;
        }
        catch (error) {
            this.logger.error(`Error retrieving access token ${this.getApplicationId()}:${resourceId}:`, error);
            throw error;
        }
    }
    /**
     * Get only the refresh token for a resource
     * @param resourceId - Unique identifier for the resource (companyId or locationId)
     * @returns Refresh token or null if not found
     */
    async getRefreshToken(resourceId) {
        try {
            const uniqueKey = this.generateUniqueKey(resourceId);
            const sessionDocument = this.sessions.get(uniqueKey);
            return sessionDocument?.refresh_token || null;
        }
        catch (error) {
            this.logger.error(`Error retrieving refresh token ${this.getApplicationId()}:${resourceId}:`, error);
            throw error;
        }
    }
    /**
     * Get all sessions for this application
     * @returns Array of session data for the application
     */
    async getSessionsByApplication() {
        try {
            const applicationId = this.getApplicationId();
            const appSessions = [];
            for (const [key, sessionData] of this.sessions.entries()) {
                if (key.startsWith(`${applicationId}:`)) {
                    const { createdAt, updatedAt, ...cleanSessionData } = sessionData;
                    appSessions.push(cleanSessionData);
                }
            }
            this.logger.debug(`Found ${appSessions.length} sessions in memory for application: ${applicationId}`);
            return appSessions;
        }
        catch (error) {
            this.logger.error(`Error retrieving sessions for application ${this.getApplicationId()}:`, error);
            throw error;
        }
    }
    /**
     * Check if the storage is initialized
     * @returns Initialization status
     */
    isStorageActive() {
        return this.isInitialized;
    }
    /**
     * Get current session count
     * @returns Number of sessions stored in memory
     */
    getSessionCount() {
        return this.sessions.size;
    }
    /**
     * Get all session keys (for debugging)
     * @returns Array of all session keys
     */
    getAllSessionKeys() {
        return Array.from(this.sessions.keys());
    }
    /**
     * Clear all sessions (useful for testing)
     */
    clearAllSessions() {
        const count = this.sessions.size;
        this.sessions.clear();
        this.logger.debug(`Cleared ${count} sessions from memory`);
    }
}
exports.MemorySessionStorage = MemorySessionStorage;
//# sourceMappingURL=memory-session-storage.js.map