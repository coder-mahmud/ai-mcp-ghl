"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Products = void 0;
const request_utils_1 = require("../../utils/request-utils");
/**
 * Products Service
 * Documentation for products API
 */
class Products {
    constructor(httpClient) {
        this.client = httpClient;
    }
    /**
     * Bulk Update Products
     * API to bulk update products (price, availability, collections, delete)
     */
    async bulkUpdate(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/bulk-update', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Bulk Edit Products and Prices
     * API to bulk edit products and their associated prices (max 30 entities)
     */
    async bulkEdit(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = [];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/bulk-update/edit', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Price for a Product
     * The &quot;Create Price for a Product&quot; API allows adding a new price associated with a specific product to the system. Use this endpoint to create a price with the specified details for a particular product. Ensure that the required information is provided in the request payload.
     */
    async createPriceForProduct(params, requestBody, options) {
        const paramDefs = [{ name: 'productId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/{productId}/price', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * List Prices for a Product
     * The &quot;List Prices for a Product&quot; API allows retrieving a paginated list of prices associated with a specific product. Customize your results by filtering prices or paginate through the list using the provided query parameters.
     */
    async listPricesForProduct(params, options) {
        const paramDefs = [{ name: 'productId', in: 'path' }, { name: 'limit', in: 'query' }, { name: 'offset', in: 'query' }, { name: 'locationId', in: 'query' }, { name: 'ids', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/{productId}/price', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * List Inventory
     * The &quot;List Inventory API allows the user to retrieve a paginated list of inventory items. Use this endpoint to fetch details for multiple items in the inventory based on the provided query parameters.
     */
    async getListInventory(params, options) {
        const paramDefs = [{ name: 'limit', in: 'query' }, { name: 'offset', in: 'query' }, { name: 'altId', in: 'query' }, { name: 'altType', in: 'query' }, { name: 'search', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/inventory', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Inventory
     * The Update Inventory API allows the user to bulk update the inventory for multiple items. Use this endpoint to update the available quantity and out-of-stock purchase settings for multiple items in the inventory.
     */
    async updateInventory(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/inventory', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Price by ID for a Product
     * The &quot;Get Price by ID for a Product&quot; API allows retrieving information for a specific price associated with a particular product using its unique identifier. Use this endpoint to fetch details for a single price based on the provided price ID and product ID.
     */
    async getPriceByIdForProduct(params, options) {
        const paramDefs = [{ name: 'productId', in: 'path' }, { name: 'priceId', in: 'path' }, { name: 'locationId', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/{productId}/price/{priceId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Price by ID for a Product
     * The &quot;Update Price by ID for a Product&quot; API allows modifying information for a specific price associated with a particular product using its unique identifier. Use this endpoint to update details for a single price based on the provided price ID and product ID.
     */
    async updatePriceByIdForProduct(params, requestBody, options) {
        const paramDefs = [{ name: 'productId', in: 'path' }, { name: 'priceId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/products/{productId}/price/{priceId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Price by ID for a Product
     * The &quot;Delete Price by ID for a Product&quot; API allows deleting a specific price associated with a particular product using its unique identifier. Use this endpoint to remove a price from the system.
     */
    async deletePriceByIdForProduct(params, options) {
        const paramDefs = [{ name: 'productId', in: 'path' }, { name: 'priceId', in: 'path' }, { name: 'locationId', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/products/{productId}/price/{priceId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Fetch Product Store Stats
     * API to fetch the total number of products, included in the store, and excluded from the store and other stats
     */
    async getProductStoreStats(params, options) {
        const paramDefs = [{ name: 'storeId', in: 'path' }, { name: 'altId', in: 'query' }, { name: 'altType', in: 'query' }, { name: 'search', in: 'query' }, { name: 'collectionIds', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/store/{storeId}/stats', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Action to include/exclude the product in store
     * API to update the status of products in a particular store
     */
    async updateStoreStatus(params, requestBody, options) {
        const paramDefs = [{ name: 'storeId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/store/{storeId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update product display priorities in store
     * API to set the display priority of products in a store
     */
    async updateDisplayPriority(params, requestBody, options) {
        const paramDefs = [{ name: 'storeId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/store/{storeId}/priority', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Fetch Product Collections
     * Internal API to fetch the Product Collections
     */
    async getProductCollection(params, options) {
        const paramDefs = [{ name: 'limit', in: 'query' }, { name: 'offset', in: 'query' }, { name: 'altId', in: 'query' }, { name: 'altType', in: 'query' }, { name: 'collectionIds', in: 'query' }, { name: 'name', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/collections', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Product Collection
     * Create a new Product Collection for a specific location
     */
    async createProductCollection(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/collections', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Details about individual product collection
     * Get Details about individual product collection
     */
    async getProductCollectionId(params, options) {
        const paramDefs = [{ name: 'collectionId', in: 'path' }, { name: 'altId', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/collections/{collectionId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Product Collection
     * Update a specific product collection with Id :collectionId
     */
    async updateProductCollection(params, requestBody, options) {
        const paramDefs = [{ name: 'collectionId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/products/collections/{collectionId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Product Collection
     * Delete specific product collection with Id :collectionId
     */
    async deleteProductCollection(params, options) {
        const paramDefs = [{ name: 'collectionId', in: 'path' }, { name: 'altId', in: 'query' }, { name: 'altType', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/products/collections/{collectionId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Fetch Product Reviews
     * API to fetch the Product Reviews
     */
    async getProductReviews(params, options) {
        const paramDefs = [{ name: 'altId', in: 'query' }, { name: 'altType', in: 'query' }, { name: 'limit', in: 'query' }, { name: 'offset', in: 'query' }, { name: 'sortField', in: 'query' }, { name: 'sortOrder', in: 'query' }, { name: 'rating', in: 'query' }, { name: 'startDate', in: 'query' }, { name: 'endDate', in: 'query' }, { name: 'productId', in: 'query' }, { name: 'storeId', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/reviews', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Fetch Review Count as per status
     * API to fetch the Review Count as per status
     */
    async getReviewsCount(params, options) {
        const paramDefs = [{ name: 'altId', in: 'query' }, { name: 'altType', in: 'query' }, { name: 'rating', in: 'query' }, { name: 'startDate', in: 'query' }, { name: 'endDate', in: 'query' }, { name: 'productId', in: 'query' }, { name: 'storeId', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/reviews/count', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Product Reviews
     * Update status, reply, etc of a particular review
     */
    async updateProductReview(params, requestBody, options) {
        const paramDefs = [{ name: 'reviewId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/products/reviews/{reviewId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Product Review
     * Delete specific product review
     */
    async deleteProductReview(params, options) {
        const paramDefs = [{ name: 'reviewId', in: 'path' }, { name: 'altId', in: 'query' }, { name: 'altType', in: 'query' }, { name: 'productId', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/products/reviews/{reviewId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Product Reviews
     * Update one or multiple product reviews: status, reply, etc.
     */
    async bulkUpdateProductReview(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/reviews/bulk-update', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Product by ID
     * The &quot;Get Product by ID&quot; API allows to retrieve information for a specific product using its unique identifier. Use this endpoint to fetch details for a single product based on the provided product ID.
     */
    async getProductById(params, options) {
        const paramDefs = [{ name: 'productId', in: 'path' }, { name: 'locationId', in: 'query' }, { name: 'sendWishlistStatus', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/{productId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Product by ID
     * The &quot;Delete Product by ID&quot; API allows deleting a specific product using its unique identifier. Use this endpoint to remove a product from the system.
     */
    async deleteProductById(params, options) {
        const paramDefs = [{ name: 'productId', in: 'path' }, { name: 'locationId', in: 'query' }, { name: 'sendWishlistStatus', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/products/{productId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Product by ID
     * The &quot;Update Product by ID&quot; API allows modifying information for a specific product using its unique identifier. Use this endpoint to update details for a single product based on the provided product ID.
     */
    async updateProductById(params, requestBody, options) {
        const paramDefs = [{ name: 'productId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/products/{productId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Product
     * The &quot;Create Product&quot; API allows adding a new product to the system. Use this endpoint to create a product with the specified details. Ensure that the required information is provided in the request payload.
     */
    async createProduct(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/products/', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * List Products
     * The &quot;List Products&quot; API allows to retrieve a paginated list of products. Customize your results by filtering products based on name or paginate through the list using the provided query parameters. This endpoint provides a straightforward way to explore and retrieve product information.
     */
    async listInvoices(params, options) {
        const paramDefs = [{ name: 'limit', in: 'query' }, { name: 'offset', in: 'query' }, { name: 'locationId', in: 'query' }, { name: 'search', in: 'query' }, { name: 'collectionIds', in: 'query' }, { name: 'collectionSlug', in: 'query' }, { name: 'expand', in: 'query' }, { name: 'productIds', in: 'query' }, { name: 'storeId', in: 'query' }, { name: 'includedInStore', in: 'query' }, { name: 'availableInStore', in: 'query' }, { name: 'sortOrder', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/products/', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
}
exports.Products = Products;
exports.default = Products;
//# sourceMappingURL=products.js.map