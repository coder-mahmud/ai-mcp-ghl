"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Conversations = void 0;
const request_utils_1 = require("../../utils/request-utils");
/**
 * Conversations Service
 * Documentation for Conversations API
 */
class Conversations {
    constructor(httpClient) {
        this.client = httpClient;
    }
    /**
     * Search Conversations
     * Returns a list of all conversations matching the search criteria along with the sort and filter options selected.
     */
    async searchConversation(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'query' }, { name: 'contactId', in: 'query' }, { name: 'assignedTo', in: 'query' }, { name: 'followers', in: 'query' }, { name: 'mentions', in: 'query' }, { name: 'query', in: 'query' }, { name: 'sort', in: 'query' }, { name: 'startAfterDate', in: 'query' }, { name: 'id', in: 'query' }, { name: 'limit', in: 'query' }, { name: 'lastMessageType', in: 'query' }, { name: 'lastMessageAction', in: 'query' }, { name: 'lastMessageDirection', in: 'query' }, { name: 'status', in: 'query' }, { name: 'sortBy', in: 'query' }, { name: 'sortScoreProfile', in: 'query' }, { name: 'scoreProfile', in: 'query' }, { name: 'scoreProfileMin', in: 'query' }, { name: 'scoreProfileMax', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/conversations/search', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Conversation
     * Get the conversation details based on the conversation ID
     */
    async getConversation(params, options) {
        const paramDefs = [{ name: 'conversationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/conversations/{conversationId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Conversation
     * Update the conversation details based on the conversation ID
     */
    async updateConversation(params, requestBody, options) {
        const paramDefs = [{ name: 'conversationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/conversations/{conversationId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Conversation
     * Delete the conversation details based on the conversation ID
     */
    async deleteConversation(params, options) {
        const paramDefs = [{ name: 'conversationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/conversations/{conversationId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get email by Id
     * Get email by Id
     */
    async getEmailById(options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = [];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/email/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Cancel a scheduled email message.
     * Post the messageId for the API to delete a scheduled email message. &lt;br /&gt;
     */
    async cancelScheduledEmailMessage(params, options) {
        const paramDefs = [{ name: 'emailMessageId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = [];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/email/{emailMessageId}/schedule', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get message by message id
     * Get message by message id.
     */
    async getMessage(options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get messages by conversation id
     * Get messages by conversation id.
     */
    async getMessages(params, options) {
        const paramDefs = [{ name: 'conversationId', in: 'path' }, { name: 'lastMessageId', in: 'query' }, { name: 'limit', in: 'query' }, { name: 'type', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/conversations/{conversationId}/messages', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Send a new message
     * Post the necessary fields for the API to send a new message.
     */
    async sendANewMessage(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/conversations/messages', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Add an inbound message
     * Post the necessary fields for the API to add a new inbound message. &lt;br /&gt;
     */
    async addAnInboundMessage(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/inbound', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Add an external outbound call
     * Post the necessary fields for the API to add a new outbound call.
     */
    async addAnOutboundMessage(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/outbound', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Cancel a scheduled message.
     * Post the messageId for the API to delete a scheduled message. &lt;br /&gt;
     */
    async cancelScheduledMessage(params, options) {
        const paramDefs = [{ name: 'messageId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/{messageId}/schedule', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Upload file attachments
     * Post the necessary fields for the API to upload files. The files need to be a buffer with the key &quot;fileAttachment&quot;. &lt;br /&gt;&lt;br /&gt; The allowed file types are: &lt;br/&gt; &lt;ul&gt;&lt;li&gt;JPG&lt;/li&gt;&lt;li&gt;JPEG&lt;/li&gt;&lt;li&gt;PNG&lt;/li&gt;&lt;li&gt;MP4&lt;/li&gt;&lt;li&gt;MPEG&lt;/li&gt;&lt;li&gt;ZIP&lt;/li&gt;&lt;li&gt;RAR&lt;/li&gt;&lt;li&gt;PDF&lt;/li&gt;&lt;li&gt;DOC&lt;/li&gt;&lt;li&gt;DOCX&lt;/li&gt;&lt;li&gt;TXT&lt;/li&gt;&lt;li&gt;MP3&lt;/li&gt;&lt;li&gt;WAV&lt;/li&gt;&lt;/ul&gt; &lt;br /&gt;&lt;br /&gt; The API will return an object with the URLs
     */
    async uploadFileAttachments(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/upload', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update message status
     * Post the necessary fields for the API to update message status.
     */
    async updateMessageStatus(params, requestBody, options) {
        const paramDefs = [{ name: 'messageId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/{messageId}/status', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Recording by Message ID
     * Get the recording for a message by passing the message id
     */
    async getMessageRecording(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'messageId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer", "Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/conversations/messages/{messageId}/locations/{locationId}/recording', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get transcription by Message ID
     * Get the recording transcription for a message by passing the message id
     */
    async getMessageTranscription(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'messageId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer", "Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/conversations/locations/{locationId}/messages/{messageId}/transcription', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Download transcription by Message ID
     * Download the recording transcription for a message by passing the message id
     */
    async downloadMessageTranscription(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'messageId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer", "Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/conversations/locations/{locationId}/messages/{messageId}/transcription/download', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Agent/Ai-Bot is typing a message indicator for live chat
     * Agent/AI-Bot will call this when they are typing a message in live chat message
     */
    async liveChatAgentTyping(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["Location-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/conversations/providers/live-chat/typing', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Conversation
     * Creates a new conversation with the data provided
     */
    async createConversation(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/conversations/', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
}
exports.Conversations = Conversations;
exports.default = Conversations;
//# sourceMappingURL=conversations.js.map