"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Locations = void 0;
const request_utils_1 = require("../../utils/request-utils");
/**
 * Locations Service
 * Documentation for Sub-Account (Formerly location) API
 */
class Locations {
    constructor(httpClient) {
        this.client = httpClient;
    }
    /**
     * Search
     * Search Sub-Account (Formerly Location)
     */
    async searchLocations(params, options) {
        const paramDefs = [{ name: 'companyId', in: 'query' }, { name: 'skip', in: 'query' }, { name: 'limit', in: 'query' }, { name: 'order', in: 'query' }, { name: 'email', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Agency-Access", "Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/search', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Sub-Account (Formerly Location)
     * Get details of a Sub-Account (Formerly Location) by passing the sub-account id
     */
    async getLocation(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Location-Access", "Agency-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __preferredTokenType: options?.preferredTokenType,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {}, options?.preferredTokenType);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Put Sub-Account (Formerly Location)
     * Update a Sub-Account (Formerly Location) based on the data provided
     */
    async putLocation(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Agency-Access"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Sub-Account (Formerly Location)
     * Delete a Sub-Account (Formerly Location) from the Agency
     */
    async deleteLocation(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'deleteTwilioAccount', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["Agency-Access"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Tags
     * Get Sub-Account (Formerly Location) Tags
     */
    async getLocationTags(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/tags', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Tag
     * Create tag
     */
    async createTag(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/tags', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get tag by id
     * Get tag by id
     */
    async getTagById(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'tagId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/tags/{tagId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update tag
     * Update tag
     */
    async updateTag(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'tagId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/tags/{tagId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete tag
     * Delete tag
     */
    async deleteTag(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'tagId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/tags/{tagId}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Task Search Filter
     * Task Search
     */
    async taskSearch(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/tasks/search', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Recurring Task By Id
     * Get Recurring Task By Id
     */
    async getRecurringTaskById(params, options) {
        const paramDefs = [{ name: 'id', in: 'path' }, { name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/recurring-tasks/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Recurring Task
     * Update Recurring Task
     */
    async updateRecurringTask(params, requestBody, options) {
        const paramDefs = [{ name: 'id', in: 'path' }, { name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/recurring-tasks/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Recurring Task
     * Delete Recurring Task
     */
    async deleteRecurringTask(params, options) {
        const paramDefs = [{ name: 'id', in: 'path' }, { name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/recurring-tasks/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Recurring Task
     * Create Recurring Task
     */
    async createRecurringTask(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/recurring-tasks', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Custom Fields
     * Get Custom Fields
     */
    async getCustomFields(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'model', in: 'query' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customFields', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Custom Field
     * Create Custom Field
     */
    async createCustomField(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customFields', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Custom Field
     * Get Custom Field
     */
    async getCustomField(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'id', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customFields/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Custom Field
     * Update Custom Field
     */
    async updateCustomField(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'id', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customFields/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Custom Field
     * Delete Custom Field
     */
    async deleteCustomField(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'id', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customFields/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Uploads File to customFields
     * Uploads File to customFields
     */
    async uploadFileCustomFields(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customFields/upload', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Custom Values
     * Get Custom Values
     */
    async getCustomValues(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customValues', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Custom Value
     * Create Custom Value
     */
    async createCustomValue(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customValues', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Get Custom Value
     * Get Custom Value
     */
    async getCustomValue(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'id', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customValues/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Update Custom Value
     * Update Custom Value
     */
    async updateCustomValue(params, requestBody, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'id', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'PUT',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customValues/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Delete Custom Value
     * Delete Custom Value
     */
    async deleteCustomValue(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'id', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/customValues/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Fetch Timezones
     * Fetch the available timezones
     */
    async getTimezones(options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["bearer", "Location-Access"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/timezones', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * GET all or email/sms templates
     * GET all or email/sms templates
     */
    async gETAllOrEmailSmsTemplates(params, options) {
        const paramDefs = [{ name: 'deleted', in: 'query' }, { name: 'skip', in: 'query' }, { name: 'limit', in: 'query' }, { name: 'type', in: 'query' }, { name: 'originId', in: 'query' }, { name: 'locationId', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'GET',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/templates', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * DELETE an email/sms template
     * DELETE an email/sms template
     */
    async dELETEAnEmailSmsTemplate(params, options) {
        const paramDefs = [{ name: 'locationId', in: 'path' }, { name: 'id', in: 'path' }];
        const extracted = (0, request_utils_1.extractParams)(params, paramDefs);
        const requirements = ["bearer"];
        const config = {
            method: 'DELETE',
            url: (0, request_utils_1.buildUrl)('/locations/{locationId}/templates/{id}', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, {});
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
    /**
     * Create Sub-Account (Formerly Location)
     * &lt;div&gt;
                    &lt;p&gt;Create a new Sub-Account (Formerly Location) based on the data provided&lt;/p&gt;
                    &lt;div&gt;
                      &lt;span style&#x3D; &quot;display: inline-block;
                                  width: 25px; height: 25px;
                                  background-color: yellow;
                                  color: black;
                                  font-weight: bold;
                                  font-size: 24px;
                                  text-align: center;
                                  line-height: 22px;
                                  border: 2px solid black;
                                  border-radius: 10%;
                                  margin-right: 10px;&quot;&gt;
                                  !
                        &lt;/span&gt;
                        &lt;span&gt;
                          &lt;strong&gt;
                            This feature is only available on Agency Pro ($497) plan.
                          &lt;/strong&gt;
                        &lt;/span&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
      
     */
    async createLocation(requestBody, options) {
        const paramDefs = [];
        const extracted = (0, request_utils_1.extractParams)(null, paramDefs);
        const requirements = ["Agency-Access"];
        const config = {
            method: 'POST',
            url: (0, request_utils_1.buildUrl)('/locations/', extracted.path),
            params: extracted.query,
            headers: { ...extracted.header, ...options?.headers },
            data: requestBody,
            __secutiryRequirements: requirements,
            __pathParams: extracted.path,
            ...options
        };
        const authToken = await (0, request_utils_1.getAuthToken)(this.client, requirements, config.headers || {}, { ...config.params || {}, ...config.__pathParams }, requestBody);
        if (authToken) {
            config.headers = { ...config.headers, Authorization: authToken };
        }
        const response = await this.client.request(config);
        return response.data;
    }
}
exports.Locations = Locations;
exports.default = Locations;
//# sourceMappingURL=locations.js.map